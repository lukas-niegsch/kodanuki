#version 450
#define M_PI 3.1415926535897932384626433832795

layout (local_size_x = 128) in;

layout (binding = 0) uniform UD {
	float delta_time;
	float kernel_size;
	float stiffness;
	float rho_0;
	float gravity;
	float viscosity;
	uint particle_count;
} ud;

layout (binding = 1) buffer pos1 { vec4 inPosition[]; };
layout (binding = 2) buffer mass { float inMass[]; };
layout (binding = 3) buffer dens { float outDensity[]; };
layout (binding = 4) buffer pres { float outPressure[]; };

/**
 * Calculates the discrete kernel function using cubic splines.
 * 
 * This is the same method as used in the paper. Different kernel functions
 * are possible and it's a tradeoff between accuracy and computational cost.
 */
float cubic_spline_kernel(vec3 xi, vec3 xj, float h)
{
	const float q = length(xi - xj) / h;

	if (q >= 2) {
		return 0.0;
	}

	const float c = 3 / (2 * M_PI);

	if (q < 1) {
		return c * (2 / 3 - pow(q, 2) + pow(q, 3) / 2);
	} else {
		return c * pow(2 - q, 3) / 6;
	}
}

/**
 * Calculates the discrete gradiant of the cubic splines kernel.
 *
 * This gradiant must match the implementation of the kernel function
 * defined by the cubic_spline_kernel().
 */
vec3 cubic_spline_gradiant(vec3 xi, vec3 xj, float h)
{
	const vec3 xd = xi - xj;
	const float l = length(xd);
	const float q = l / h;

	if (q >= 2) {
		return vec3(0.0);
	}

	const float c = 3 / (2 * M_PI);
	vec3 gradiant = xd * c / (l * h);

	if (q < 1) {
		gradiant *= -2 * q + 3 * pow(q, 2) / 2 ;
	} else {
		gradiant *= -3 * pow(2 - q, 2) / 6;
	}

	return gradiant;
}

/**
 * Calculates the density of the particle.
 *
 * This is the derived equation from the SPH equations. We do no search for
 * the neighborhood yet. Particles who are very far away get discarded, but
 * the performance is still O(N^2).
 */
float calculate_density(vec3 x, float m, float h)
{
	float density = 0;

	for (uint j = 0; j < ud.particle_count; j++) {
		density += m * cubic_spline_kernel(x, inPosition[j].xyz, h);
	}

	return density;
}

/**
 * Calculates the pressure at the particle.
 *
 * This is some example equation that is used in the paper. There are other
 * equations for approximation, but this seems to be a popular choice.
 */
float calculate_pressure(float rho_i, float rho_0, float k)
{
	return k * (pow(rho_i / rho_0, 7) - 1);
}

/**
 * For each invokation calculates the density and then the pressure using
 * the equations from the paper. This is done in many cores in parallel.
 */
void main()
{
	const uint gID = gl_GlobalInvocationID.x;

	if (ud.particle_count <= gID) {
		return;
	}

	outDensity[gID] = calculate_density(inPosition[gID].xyz, inMass[gID], ud.kernel_size);
	outPressure[gID] = calculate_pressure(outDensity[gID], ud.rho_0, ud.stiffness);
}
